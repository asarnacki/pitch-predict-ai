### 1. Lista tabel z ich kolumnami, typami danych i ograniczeniami

#### Tabela: `profiles`

This table is managed by Supabase Auth.

Tabela przechowująca publiczne dane użytkowników, oddzielone od danych autentykacyjnych z `auth.users`.

| Nazwa kolumny | Typ danych    | Ograniczenia                                                 | Opis                                    |
| ------------- | ------------- | ------------------------------------------------------------ | --------------------------------------- |
| `id`          | `uuid`        | `PRIMARY KEY`, `REFERENCES auth.users(id) ON DELETE CASCADE` | Klucz główny, powiązany z `auth.users`. |
| `created_at`  | `timestamptz` | `NOT NULL`, `DEFAULT now()`                                  | Znacznik czasu utworzenia profilu.      |

#### Tabela: `predictions`

Tabela przechowująca wszystkie zapisane przez użytkowników predykcje meczów.

| Nazwa kolumny       | Typ danych     | Ograniczenia                                            | Opis                                                                             |
| ------------------- | -------------- | ------------------------------------------------------- | -------------------------------------------------------------------------------- |
| `id`                | `bigint`       | `PRIMARY KEY`, `GENERATED BY DEFAULT AS IDENTITY`       | Klucz główny predykcji.                                                          |
| `created_at`        | `timestamptz`  | `NOT NULL`, `DEFAULT now()`                             | Znacznik czasu utworzenia predykcji.                                             |
| `user_id`           | `uuid`         | `NOT NULL`, `REFERENCES profiles(id) ON DELETE CASCADE` | Klucz obcy wskazujący na użytkownika, który zapisał predykcję.                   |
| `league`            | `text`         | `NOT NULL`                                              | Nazwa ligi (np. "Premier League").                                               |
| `match_date`        | `timestamptz`  | `NOT NULL`                                              | Data i godzina rozpoczęcia meczu.                                                |
| `home_team`         | `text`         | `NOT NULL`                                              | Nazwa drużyny gospodarzy.                                                        |
| `away_team`         | `text`         | `NOT NULL`                                              | Nazwa drużyny gości.                                                             |
| `prediction_result` | `jsonb`        | `NOT NULL`                                              | Wynik predykcji w formacie JSON (np. `{"home": 0.5, "draw": 0.3, "away": 0.2}`). |
| `note`              | `varchar(500)` |                                                         | Opcjonalna notatka użytkownika do predykcji.                                     |
| `home_score`        | `integer`      |                                                         | Liczba bramek gospodarzy (cache'owany wynik końcowy).                            |
| `away_score`        | `integer`      |                                                         | Liczba bramek gości (cache'owany wynik końcowy).                                 |

### 2. Relacje między tabelami

- **`profiles` ↔ `auth.users` (jeden-do-jednego)**
  - Każdy rekord w `auth.users` ma dokładnie jeden odpowiadający mu rekord w `profiles`. Relacja jest zaimplementowana przez `profiles.id`, który jest jednocześnie kluczem głównym i obcym wskazującym na `auth.users.id`.

- **`profiles` → `predictions` (jeden-do-wielu)**
  - Jeden użytkownik (profil) może mieć wiele zapisanych predykcji.
  - Każda predykcja należy do dokładnie jednego użytkownika.
  - Relacja jest zaimplementowana przez klucz obcy `predictions.user_id`, który wskazuje na `profiles.id`.

### 3. Indeksy

- **Indeks na `predictions.user_id`**
  - **Cel**: Optymalizacja wydajności zapytań pobierających listę "Obserwowanych meczów" dla konkretnego użytkownika.
  - **SQL**: `CREATE INDEX ON predictions (user_id);`

### 4. Zasady PostgreSQL (Row-Level Security)

W celu zapewnienia izolacji danych, na tabelach `profiles` i `predictions` zostaną włączone zabezpieczenia na poziomie wiersza (RLS).

#### Polityki dla tabeli `profiles`

- **Nazwa**: `Users can view their own profile.`
  - **Operacja**: `SELECT`
  - **Warunek**: `auth.uid() = id`

- **Nazwa**: `Users can update their own profile.`
  - **Operacja**: `UPDATE`
  - **Warunek**: `auth.uid() = id`

#### Polityki dla tabeli `predictions`

- **Nazwa**: `Users can view their own predictions.`
  - **Operacja**: `SELECT`
  - **Warunek**: `auth.uid() = user_id`

- **Nazwa**: `Users can insert their own predictions.`
  - **Operacja**: `INSERT`
  - **Warunek**: `auth.uid() = user_id`

- **Nazwa**: `Users can update their own predictions.`
  - **Operacja**: `UPDATE`
  - **Warunek**: `auth.uid() = user_id`

- **Nazwa**: `Users can delete their own predictions.`
  - **Operacja**: `DELETE`
  - **Warunek**: `auth.uid() = user_id`

### 5. Dodatkowe uwagi i wyjaśnienia

- **Denormalizacja Danych Meczu**: Dane takie jak `home_team`, `away_team`, `league` i `match_date` są celowo zdenormalizowane i przechowywane bezpośrednio w tabeli `predictions`. Upraszcza to architekturę i zapytania na etapie MVP, eliminując potrzebę tworzenia dodatkowych tabel `matches`, `teams` czy `leagues`.
- **Trigger do tworzenia profili**: Zaleca się utworzenie triggera w bazie danych, który automatycznie tworzy nowy wpis w tabeli `profiles` po dodaniu nowego użytkownika do tabeli `auth.users`.
- **Ograniczenie liczby predykcji**: Zgodnie z decyzją, limit 50 predykcji na użytkownika (FR-017) będzie implementowany w warstwie aplikacji (backend/frontend), a nie za pomocą ograniczeń w bazie danych.
- **Usuwanie kaskadowe**: W schemacie zdefiniowano `ON DELETE CASCADE` dla kluczy obcych. Oznacza to, że usunięcie użytkownika z `auth.users` spowoduje kaskadowe usunięcie jego profilu oraz wszystkich powiązanych z nim predykcji. Jest to zgodne z wymaganiem ochrony prywatności danych, chociaż kwestia ta została oznaczona jako do dalszej dyskusji.
- **Typ `JSONB`**: Użycie typu `jsonb` dla `prediction_result` zapewnia elastyczność i wydajność przy przechowywaniu i odpytywaniu strukturyzowanych, ale potencjalnie zmiennych w przyszłości, danych predykcji.
